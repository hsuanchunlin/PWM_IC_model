data <- read.csv('demo_data.csv')
sequence = data$Sequence
View(data)
temp_1 = strsplit(sequence,"")
View(temp_1)
temp_2 = t(temp_1)
View(temp_2)
temp_1 = strsplit(sequence,"") %>% data.frame()
View(temp_1)
temp_2 = t(temp_1)
View(temp_2)
temp_2 = t(temp_1) %>% data.frame()
View(temp_2)
#One-hot encoding
input_matrix <- model.matrix(~.-1, temp_1)
View(temp_2)
#One-hot encoding
input_matrix <- model.matrix(~.-1, temp_2)
View(input_matrix)
#One-hot encoding
input_matrix <- model.matrix(~., temp_2)
View(input_matrix)
#One-hot encoding
input_matrix <- model.matrix(~.1, temp_2)
#One-hot encoding
input_matrix <- model.matrix(~.-1, temp_2)
View(temp_2)
View(input_matrix)
View(temp_2)
#One-hot encoding
input_matrix <- model.matrix(~., temp_2)
View(input_matrix)
#One-hot encoding
input_matrix <- model.matrix(~ -1, temp_2)
#One-hot encoding
input_matrix <- model.matrix(~ . -1, temp_2)
View(input_matrix)
#One-hot encoding
input_matrix <- model.matrix(.-1, temp_2)
#One-hot encoding
input_matrix <- model.matrix(~X1-1, temp_2)
View(input_matrix)
#One-hot encoding
input_matrix <- model.matrix(~X2-1, temp_2)
View(input_matrix)
#One-hot encoding
input_matrix <- model.matrix(~..-1, temp_2)
#One-hot encoding
input_matrix <- model.matrix(~.-1, temp_2)
View(input_matrix)
#One-hot encoding
rownames(temp_2) <- input_matrix$Sequence
#One-hot encoding
rownames(temp_2) <- data$Sequence
View(temp_2)
input_matrix <- model.matrix(~.-1, temp_2)
View(input_matrix)
input_matrix_1 <- model.matrix(~X1-1, temp_2)
input_matrix_2 <- model.matrix(~X2-1, temp_2)
input_matrix_3 <- model.matrix(~X3-1, temp_2)
input_matrix_4 <- model.matrix(~X4-1, temp_2)
input_matrix_5 <- model.matrix(~X5-1, temp_2)
input_matrix_6 <- model.matrix(~X6-1, temp_2)
View(input_matrix_6)
input_matrix <- cbind(input_matrix_1,input_matrix_2,input_matrix_3, input_matrix_4,
input_matrix_5,input_matrix_6) %>% data.frame()
View(input_matrix)
#change colname
colnames_list <- colnames(input_matrix)
colnames(input_matrix) <- substr(colnames_list, start=2, stop=3)
input_matrix <- cbind(data, input_matrix)
rownames(input_matrix) <- input_matrix$Sequence
View(input_matrix)
write.csv("chr_table.csv", input_matrix)
write.csv(input_matrix, "chr_table.csv")
# for PWM linear regression
#load the data
# clean the data storage
rm(list= ls())
howmany <- 6
data <- read.csv("chr_table.csv")   #Read in the data from a csv
data$LNRK <- log(data$RK)
attach(data)                                #Attach the column headers to the data as variable names
#Automatic generate the pair
nucleotides <- c('A','C','G','T')
combination <- c()
k <- 1
for (i in 1:howmany){
for(j in 1:4){
combination[k] <- paste(nucleotides[j],i,sep = '')
k <- k+1
}
}
control <- c('G1','A2','T3','T4','A5','G6','T7')
#cut the control
combination <- combination[!(combination %in% control)]
#generate the command
command.a <- 'lm1 <- lm(LNRK ~'
for (i in 1:(length(combination)-1)){
command.a <- paste(command.a, combination[i], '+')
}
command.a <- paste(command.a,combination[length(combination)], ')')
eval(parse(text = command.a))
#regress reaction rate on each base-position variable, and 1 interaction term
#Get the coefficient and prepare for data visualization
coef1 <- coef(lm1)
coef1 <- coef1[-1]
coef1[is.na(coef1)] <- 0
factor1 <- names(coef1)
coef1 <- as.numeric(coef1)
loca <- cbind(factor1, coef1)
loc <- control
lon <- rep(0,length(control))
locc <- cbind(loc,lon)
locd<- rbind(loca,locc)
locb <- data.frame(locd)
locb$NT <- substr(locb[,1],1,1)
locb$POS <- (as.numeric(substr(locb[,1],2,2)))
locb[locb$NT == 'T',3] <- 'U'
locb <- as.matrix(locb)
#Using bubble chart to visualize the data
par(mar=c(5,5,2,2))
colorc <- c("lightpink",rgb(129/255,216/255,208/255),"orange","olivedrab2")
#rgb(129/255,216/255,208/255)
seq <- c('A','C','G','U')
plot(NA,NA ,pch = 21, cex = 5, col = NULL, bg = "green",
xlim = c(1,7),
ylim = c(-0.3,0.3),
xlab = "Position in Leader",
ylab = "Linear Coefficient")
for (i in 1:4)
{
nt <- seq[i]
points(locb[locb[,3]== nt ,4],locb[locb[,3]== nt ,2] ,pch = 21, cex = 5, col = NULL, bg = colorc[i])
}
for (i in 1:length(locb[,1]))
{
text(as.numeric(locb[i,4]),as.numeric(locb[i,2]),locb[i,3], col = "black")
}
# if you need abline for tick
abline(h=0)
#See the prediction quality by linear model
lc <- predict(lm1, newdata = data)
lcf <- lm(lc~data$LNRK)
plot(data$LNRK,lc,
cex = 0.5,
xlim = c(-2,1.5),
ylim = c(-2,1.5),
xlab = expression(
italic(
paste("ln(",phantom()^r*K[a], ")")
)
),
ylab = expression(
italic(
paste("predicted ln(",phantom()^r*K[a], ")")
)
)
)
text(-1.5,0.5,paste("R= ", round(summary(lcf)$r.square,2)))
detach(data)
summary(lcf)
View(data)
data <- read.csv("chr_table.csv")   #Read in the data from a csv
View(data)
howmany <- 6
nucleotides <- c('A','C','G','T')
combination <- c()
k <- 1
for (i in 1:howmany){
for(j in 1:4){
combination[k] <- paste(nucleotides[j],i,sep = '')
k <- k+1
}
}
library(tidyverse)
data <- read.csv('demo_data.csv')
sequence = data$Sequence
temp_1 = strsplit(sequence,"") %>% data.frame()
temp_2 = t(temp_1) %>% data.frame()
#tet = t(q) %>% data.frame()
#One-hot encoding
input_matrix_1 <- model.matrix(~X1-1, temp_2)
input_matrix_2 <- model.matrix(~X2-1, temp_2)
input_matrix_3 <- model.matrix(~X3-1, temp_2)
input_matrix_4 <- model.matrix(~X4-1, temp_2)
input_matrix_5 <- model.matrix(~X5-1, temp_2)
input_matrix_6 <- model.matrix(~X6-1, temp_2)
View(input_matrix_6)
#One-hot encoding
input_matrix_1 <- model.matrix(X1~-1, temp_2)
View(input_matrix_1)
#One-hot encoding
input_matrix_1 <- model.matrix(X1~.-1, temp_2)
View(input_matrix_1)
#One-hot encoding
input_matrix_1 <- model.matrix(~X1 1, temp_2)
#One-hot encoding
input_matrix_1 <- model.matrix(~X1 -1, temp_2)
View(input_matrix_1)
colnames(input_matrix) <- paste(substr(colnames_list, start=3, stop=3),
substr(colnames_list, start=2, stop=2),
sep = "")
data <- read.csv('demo_data.csv')
sequence = data$Sequence
temp_1 = strsplit(sequence,"") %>% data.frame()
temp_2 = t(temp_1) %>% data.frame()
#tet = t(q) %>% data.frame()
#One-hot encoding
input_matrix_1 <- model.matrix(~X1-1, temp_2)
input_matrix_2 <- model.matrix(~X2-1, temp_2)
input_matrix_3 <- model.matrix(~X3-1, temp_2)
input_matrix_4 <- model.matrix(~X4-1, temp_2)
input_matrix_5 <- model.matrix(~X5-1, temp_2)
input_matrix_6 <- model.matrix(~X6-1, temp_2)
input_matrix <- cbind(input_matrix_1,input_matrix_2,input_matrix_3, input_matrix_4,
input_matrix_5,input_matrix_6) %>% data.frame()
#change colname
colnames_list <- colnames(input_matrix)
colnames(input_matrix) <- paste(substr(colnames_list, start=3, stop=3),
substr(colnames_list, start=2, stop=2),
sep = "")
View(input_matrix)
input_matrix <- cbind(data, input_matrix)
rownames(input_matrix) <- input_matrix$Sequence
write.csv(input_matrix, "chr_table.csv")
rm(list= ls())
howmany <- 6
data <- read.csv("chr_table.csv")   #Read in the data from a csv
data$LNRK <- log(data$RK)
attach(data)                                #Attach the column headers to the data as variable names
#Automatic generate the pair
nucleotides <- c('A','C','G','T')
combination <- c()
k <- 1
for (i in 1:howmany){
for(j in 1:4){
combination[k] <- paste(nucleotides[j],i,sep = '')
k <- k+1
}
}
control <- c('G1','A2','T3','T4','A5','G6','T7')
#cut the control
combination <- combination[!(combination %in% control)]
#generate the command
command.a <- 'lm1 <- lm(LNRK ~'
for (i in 1:(length(combination)-1)){
command.a <- paste(command.a, combination[i], '+')
}
command.a <- paste(command.a,combination[length(combination)], ')')
eval(parse(text = command.a))
#regress reaction rate on each base-position variable, and 1 interaction term
#Get the coefficient and prepare for data visualization
coef1 <- coef(lm1)
coef1 <- coef1[-1]
coef1[is.na(coef1)] <- 0
factor1 <- names(coef1)
coef1 <- as.numeric(coef1)
loca <- cbind(factor1, coef1)
loc <- control
lon <- rep(0,length(control))
locc <- cbind(loc,lon)
locd<- rbind(loca,locc)
locb <- data.frame(locd)
locb$NT <- substr(locb[,1],1,1)
locb$POS <- (as.numeric(substr(locb[,1],2,2)))
locb[locb$NT == 'T',3] <- 'U'
locb <- as.matrix(locb)
#Using bubble chart to visualize the data
par(mar=c(5,5,2,2))
colorc <- c("lightpink",rgb(129/255,216/255,208/255),"orange","olivedrab2")
#rgb(129/255,216/255,208/255)
seq <- c('A','C','G','U')
plot(NA,NA ,pch = 21, cex = 5, col = NULL, bg = "green",
xlim = c(1,7),
ylim = c(-0.3,0.3),
xlab = "Position in Leader",
ylab = "Linear Coefficient")
for (i in 1:4)
{
nt <- seq[i]
points(locb[locb[,3]== nt ,4],locb[locb[,3]== nt ,2] ,pch = 21, cex = 5, col = NULL, bg = colorc[i])
}
for (i in 1:length(locb[,1]))
{
text(as.numeric(locb[i,4]),as.numeric(locb[i,2]),locb[i,3], col = "black")
}
# if you need abline for tick
abline(h=0)
#See the prediction quality by linear model
lc <- predict(lm1, newdata = data)
lcf <- lm(lc~data$LNRK)
plot(data$LNRK,lc,
cex = 0.5,
xlim = c(-2,1.5),
ylim = c(-2,1.5),
xlab = expression(
italic(
paste("ln(",phantom()^r*K[a], ")")
)
),
ylab = expression(
italic(
paste("predicted ln(",phantom()^r*K[a], ")")
)
)
)
text(-1.5,0.5,paste("R= ", round(summary(lcf)$r.square,2)))
detach(data)
summary(lcf)
plot(NA,NA ,pch = 21, cex = 5, col = NULL, bg = "green",
xlim = c(1,7),
ylim = c(-0.3,0.3),
xlab = "Position in Leader",
ylab = "Linear Coefficient")
for (i in 1:4)
{
nt <- seq[i]
points(locb[locb[,3]== nt ,4],locb[locb[,3]== nt ,2] ,pch = 21, cex = 5, col = NULL, bg = colorc[i])
}
for (i in 1:length(locb[,1]))
{
text(as.numeric(locb[i,4]),as.numeric(locb[i,2]),locb[i,3], col = "black")
}
abline(h=0)
# clean the data storage
rm(list= ls())
#Setup hyper parameters
howmany <- 6
controlSeq <- 'AAAAAG'
data <- read.csv("chr_table.csv")   #Read in the data from a csv
data$LNRK <- log(data$RK)
attach(data)                                #Attach the column headers to the data as variable names
#Automatic generate the pair
nucleotides <- c('A','C','G','T')
combination <- c()
k <- 1
for (i in 1:howmany){
for(j in 1:4){
combination[k] <- paste(nucleotides[j],i,sep = '')
k <- k+1
}
}
controlSeq <- unlist(strsplit(controlSeq, ''))
control <- c()
for (i in 1:length(controlSeq)){
control[i] = paste(controlSeq[i],i, sep = '')
}
#cut the control
combination <- combination[!(combination %in% control)]
#Create IC list
control.comb <- c()
k <- 1
#make the combination control
for(i in 1:length(control)){
for (j in 1:length(control)){
control.comb[k] <- paste(control[i], control[j], sep = '')
k <- k + 1
}
}
IC.command <- c() # for the command
IC.comb <- c() # for combind the chart
k <- 1
#for all the possible sequence
for (i in 1:(howmany-1)){
for (j in 1:4){
for (q in (i+1):howmany){
for(p in 1:4){
IC.command[k] <- paste(nucleotides[j],i,nucleotides[p],q,'<-',nucleotides[j],i,'*',nucleotides[p],q,sep = '')
IC.comb[k] <- paste(nucleotides[j],i,nucleotides[p],q,sep = '')
k <- k+1
}
}
}
}
#for the control
#execute the command
for (i in 1:length(IC.command)){
eval(parse(text = IC.command[i]))
}
command.a <- 'DF <- data.frame('
for (i in 1:(length(IC.comb)-1)){
command.a <- paste(command.a, IC.comb[i], ',', sep = '')
}
command.a <- paste(command.a,IC.comb[length(IC.comb)], ')', sep = '')
eval(parse(text = command.a))
#start the PWM + IC
DINUCINT <- c()
TVAL <- c()
#generate the command
command.a <- 'lm1 <- lm(LNRK ~'
for (i in 1:(length(combination))){
command.a <- paste(command.a, combination[i], '+')
}
command.b <- paste(command.a, 'DF[,n] )')
for(n in 1:length(DF)){   #for each interaction term
#regress reaction rate on each base-position variable, and 1 interaction term
eval(parse(text = command.b))
DINUCINT[n] <- mean(coefficients(lm1)[length(coefficients(lm1))])       #store the effect size of the interaction term
if(length(summary(lm1)$coefficients[,3] >= length(coefficients(lm1)))){
TVAL[n] <- summary(lm1)$coefficients[length(summary(lm1)$coefficients[,3]),3]
}else{
TVAL[n] = 0
}
#store the t-value of the interaction term
}
DINUCINT    #display interaction effect sizes
TVAL        #display T-values
whichin <- which(abs(TVAL) > 3.5)  #tells you which interaction terms have strongly statisticaly signficant interactions (T-statistcs greater than 3.5 standard deviations from the mean)
dataForlm <- cbind(data,DF)
DFname <- colnames(DF)
#convert the string to the command
command1 <- ""
for (i in 1:length(whichin))
{
str <- whichin[i]
command1 <- paste(command1, "+", DFname[str]  ,sep = " ")
}
command2 <- 'model3 <- lm(LNRK ~'
for (i in 1:(length(combination))){
command2 <- paste(command2, combination[i], '+')
}
commandf <- paste(command2, command1,", data = dataForlm)",sep = "")
eval(parse(text = commandf))
#Fill in DF[,1] + DF[,10] ... with the indices given to you by the which command.
#These happen to be the ones from this model
model4 <- step(model3)  # runs stepwise regression to pare down the variable list, and to exclude redundant/superflous interaction terms
summary(model4) # gives the summary of the final model
# plot the result
Ka4 <- predict(model4, newdata=dataForlm)
plotfig4 <- cbind(data$LNRK,Ka4)
plotfig4<-data.frame(plotfig4)
names(plotfig4) <- c("x","y")
fits4 <- lm(y~x, data = plotfig4)
par(mar=c(5,5,2,2))
plot(plotfig4,
ylab = expression(paste(italic(ln(K["A,rel"])), ", predicted by model4")),
xlab = expression(paste(italic(ln(K["A,rel"])), ", experimental")),
xlim = c(-8,1.5),
ylim = c(-8,1.5),
cex = 0.5,
cex.lab = 7/6,
cex.axis = 7/6)
text(-6,0.5,paste("R2 = ",round(summary(fits4)$r.square,2), sep = ""), cex = 7/6)
smoothScatter(plotfig4,
ylab = expression(paste(italic(ln(K["A,rel"])), ", predicted by model4")),
xlab = expression(paste(italic(ln(K["A,rel"])), ", experimental")),
xlim = c(-8,1.5),
ylim = c(-8,1.5),
cex = 0.5,
cex.lab = 7/6,
cex.axis = 7/6)
text(-6,0.5,paste("R2 = ",round(summary(fits4)$r.square,2), sep = ""), cex = 7/6)
#abline(fits4, col = "red", lwd = 3)
#plot the heatmap
colNamedf <- colnames(DF)
matrix1 <- cbind(colNamedf,matrix(0,length(colNamedf),1))
names(matrix1) <- c("N","V")
matrix1 <- cbind(colNamedf,DINUCINT)
#replace T to U
#matrix1 <- gsub("T","U",matrix1)
#new method
matrix2 <- matrix1
matrix2 <- data.frame(matrix2)
C <- (as.numeric(substr(matrix2[,1],2,2)))
matrix2$X1 <- paste(C,substr(matrix2[,1],1,1),sep = "")
D<- (as.numeric(substr(matrix2[,1],4,4)))
matrix2$X2 <- paste(D,substr(matrix2[,1],3,3),sep = "")
detach(data)
model4.coef <- coef(model4)
model4.coef<- data.frame(model4.coef)
model4.coef$NAME <- rownames(model4.coef)
model4.coef <- model4.coef[-1,]
#model4.coef$NAME <- gsub("T","U",model4.coef$NAME)
C <- -(as.numeric(substr(model4.coef[,2],2,2))+2)
model4.coef$X1 <- paste(C,substr(model4.coef[,2],1,1),sep = "")
D<- -(as.numeric(substr(model4.coef[,2],4,4))+2)
model4.coef$X2 <- paste(D,substr(model4.coef[,2],3,3),sep = "")
model4.coef$X2[model4.coef$X2 == "NA"] <- model4.coef$X1[model4.coef$X2 == "NA"]
write.csv(matrix2, "ESS3_heat.csv")
write.csv(model4.coef, "model4_real_number.csv")
write.csv(matrix2, "demo_heat.csv")
write.csv(model4.coef, "demo_model4_real_number.csv")
hm <- read.csv("demo_heat.csv")
(p <- ggplot(hm,aes(X2,X1))
+geom_tile(aes(fill = DINUCINT),colour = "gray")
+scale_fill_gradient2(low="steelblue",mid="white",
high="red", midpoint=0,space = "rgb",
na.value = "grey50", guide = "colourbar",
name = "HiTS-EQ")
+theme_bw()
+ theme(text = element_text(size=20),
axis.text= element_text(size=20,colour="black"))
+labs(size= 20,
x = "",
y = ""))
BcKINB <- read.csv("demo_model4_real_number.csv")
BcKINB[is.na(BcKINB)] <- 0
(p <- ggplot(BcKINB,aes(X2,X1))
+geom_tile(aes(fill = model4.coef),colour = "gray")
+scale_fill_gradient2(low="steelblue",mid="white",
high="red", midpoint=0,space = "rgb",
na.value = "grey50", guide = "colourbar",
name = "HiTS-EQ IC")
+theme_bw()
+ theme(text = element_text(size=20),
axis.text= element_text(size=20,colour="black"))
+theme(panel.background = element_rect(fill = "white"))
+labs(size= 20,
x = "",
y = ""))
write.csv(BcKINB,"KINMODEL4.csv")
